import { ConnectionFactoryRabbitMQ } from '../connection/connection.factory.rabbitmq';
import * as AmqpLib from 'amqplib/callback_api';
import { BusMessage } from './bus.message';
import { IExchangeInitializeResult, IExchangeOptions } from '../../../application/port/exchange.option.interface';
import { IActivateConsumerOptions, IStartConsumerOptions } from '../../../application/port/queue.option.interface';
import { IBinding } from '../../port/bus/binding.interface';
export declare class Exchange {
    private _initialized;
    private _consumer_handlers;
    private _connection;
    private _channel;
    private _name;
    private _type;
    private _options;
    private _deleting;
    private _closing;
    constructor(connection: ConnectionFactoryRabbitMQ, name: string, type?: string, options?: IExchangeOptions);
    readonly initialized: Promise<IExchangeInitializeResult>;
    readonly connection: ConnectionFactoryRabbitMQ;
    readonly channel: AmqpLib.Channel;
    readonly name: string;
    readonly options: IExchangeOptions;
    readonly type: string;
    _initialize(): void;
    publish(content: any, routingKey?: string, options?: any): void;
    send(message: BusMessage, routingKey?: string): void;
    rpc(requestParameters: any, routingKey: string, callback: (err: any, message: BusMessage) => void): void;
    delete(): Promise<void>;
    close(): Promise<void>;
    bind(source: Exchange, pattern?: string, args?: any): Promise<IBinding>;
    unbind(source: Exchange, pattern?: string, args?: any): Promise<void>;
    consumerQueueName(): string;
    startConsumer(onMessage: (msg: any, channel?: AmqpLib.Channel) => any, options?: IStartConsumerOptions): Promise<any>;
    activateConsumer(onMessage: (msg: BusMessage) => any, options?: IActivateConsumerOptions): Promise<any>;
    stopConsumer(): Promise<any>;
}
